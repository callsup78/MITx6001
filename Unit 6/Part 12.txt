Exercise 1

In this problem, we'll examine how indirection works. Consider the following definitions:
a = [1, 2, 3, 4, 0]
b = [3, 0, 2, 4, 1]
c = [3, 2, 4, 1, 5]

1: 
What is the value of the following expressions? If you think there will be an error, please 
type in 'error' (without quotes) in the input box.

1: a[0]
Correct: 1


2: b[1]
Correct: 0


3: a[a[1]]
Correct: 3


4: b[b[2]]
Correct: 2


5: a[b[2]]
Correct: 3


6: c[a[b[3]]]
Correct: 3


7: a[c[a[b[0]]]]
Correct: error


8:a[c[a[b[3]]]] 
Correct: 4



2: 
Assume we have defined the following function:

def foo(L):
    val = L[0]
    while (True):
        val = L[val]

Which of the following statement(s) will result in an infinite loop?

Correct: foo(a)
Correct: foo(b)
Incorrect: foo(c)



3:
Consider the following code:

num = ???
L = [5, 0, 2, 4, 6, 3, 1]
val = 0
for i in range(0, num):
    val = L[L[val]]

print(val)

1: What is the smallest value that num can be such that the number 3 is printed?
Correct: 1


2: Now, we redefine L to be:

L = [2, 0, 1, 5, 3, 4]

What is the smallest value that num can be such that the number 3 is printed?
Correct: Impossible



3:
Consider the following code:

num = ???
L = [5, 0, 2, 4, 6, 3, 1]
val = 0
for i in range(0, num):
    val = L[L[val]]

print(val)

1: What is the smallest value that num can be such that the number 3 is printed?
Correct: 1


2: Now, we redefine L to be:

L = [2, 0, 1, 5, 3, 4]

What is the smallest value that num can be such that the number 3 is printed?
Correct: Impossible


----------
Exercise 2

Here is some code for linear search that uses the fact that a set of elements is sorted in increasing order:

def search(L, e):
    for i in range(len(L)):
        if L[i] == e:
            return True
        if L[i] > e:
            return False
    return False

Consider the following code, which is an alternative version of search.

def search1(L, e):
    for i in L:
        if i == e:
            return True
        if i > e:
            return False
    return False

Which of the following statements is correct? You may assume that each function is tested 
with a list L whose elements are sorted in increasing order; for simplicity, assume L is a list of 
positive integers.

Correct: search and search1 return the same answers.


----------
Exercise 3

Here is some code for linear search that uses the fact that a set of elements is sorted in increasing order:

def search(L, e):
    for i in range(len(L)):
        if L[i] == e:
            return True
        if L[i] > e:
            return False
    return False

Consider the following code, which is an alternative version of search.

def search2(L, e):
    for i in L:
        if i == e:
            return True
        elif i > e:
            return False
    return False

Which of the following statements is correct? You may assume that each function is tested with 
a list L whose elements are sorted in increasing order. For simplicity, assume L is a list of integers.

Correct: search and search2 return the same answers. 


----------
Exercise 4

Here is some code for linear search that uses the fact that a set of elements is sorted in increasing order:

def search(L, e):
    for i in range(len(L)):
        if L[i] == e:
            return True
        if L[i] > e:
            return False
    return False

Consider the following code, which is an alternative version of search.

def search3(L, e):
    if L[0] == e:
        return True
    elif L[0] > e:
        return False
    else:
        return search3(L[1:], e)

Which of the following statements is correct? You may assume that each function is tested with a list 
L whose elements are sorted in increasing order. For simplicity, assume L is a list of integers.

Correct: search and search3 return the same answers provided L is non-empty and e is in L. 


----------
Exercise 5

Here is the code for selection sort. For simplicity, assume L is a list of integers:

def selSort(L):
    for i in range(len(L) - 1):
        minIndx = i
        minVal = L[i]
        j = i+1
        while j < len(L):
            if minVal > L[j]:
                minIndx = j
                minVal = L[j]
            j += 1
        if minIndx != i:
            temp = L[i]
            L[i] = L[minIndx]
            L[minIndx] = temp

And here is a suggested alternative:

def newSort(L):
    for i in range(len(L) - 1):
        j=i+1
        while j < len(L):
            if L[i] > L[j]:
                temp = L[i]
                L[i] = L[j]
                L[j] = temp
            j += 1

1:
Do these two functions result in the same sorted lists?

Correct: Yes


2:
Do these two functions execute the same number of assignments of values into entries of the lists?

Correct: No. newSort may use more - but never fewer - inserts than selSort.


3:
Is the worst-case order of growth of these functions the same?

Correct: Yes. newSort and selSort have the same complexity.


----------
Exercise 6

Here is another version of a sorting function:

def mySort(L):
    """ L, list with unique elements """
    clear = False
    while not clear:
        clear = True
        for j in range(1, len(L)):
            if L[j-1] > L[j]:
                clear = False
                temp = L[j]
                L[j] = L[j-1]
                L[j-1] = temp

Compare this to:

def newSort(L):
    """ L, list with unique elements """
    for i in range(len(L) - 1):
        j=i+1
        while j < len(L):
            if L[i] > L[j]:
                temp = L[i]
                L[i] = L[j]
                L[j] = temp
            j += 1

1:
Do these two functions result in the same sorted lists?

Correct: Yes


2:
Do these two functions execute the same number of assignments of values into entries of the lists?

Correct: Yes. They execute the same number of assignments.


3:
Is the worst-case order of growth of these functions the same?

Correct: Yes. newSort and mySort have the same complexity.


4:
Do these two functions examine the same number of entries in the list?

Correct:    No. mySort and newSort examine different numbers of entries, but one cannot always 
say which function will examine the most entries.


----------
Exercise 7

This problem will walk through some applications of complexity analysis. Suppose you're asked to 
implement an application. One of the things it has to do is to report whether or not an item, x, 
is in a list L. L's contents do not change over time. Below are two possible ways to implement this 
functionality. Assume that mergeSort is implemented as per the lecture.

L is a list with n items.

    Application A:

    Every time it's asked to, it performs a linear search through list L to find whether it contains x.

    Application B:

    Sort list L once before doing anything else (using mergeSort). Whenever it's asked to find x in L, 
    it performs a binary search on L.


1:
If the application is asked to find x in L exactly one time, what is the worst case time complexity 
for Application A?

Correct: 𝑂(𝑛)


2:
If the application is asked to find x in L exactly one time, what is the worst case time complexity 
for Application B?

Correct: 𝑂(𝑛log𝑛)
    

3:
If the application is asked to find x in L k times, what is the worst case time complexity for 
Application A?

Correct: 𝑂(𝑘𝑛)


4:
If the application is asked to find x in L k times, what is the worst case time complexity for 
Application B?

Correct: 𝑂(𝑛log𝑛+𝑘log𝑛)


5:
What value(s) of k would make Application A be faster (i.e., asymptotically grow slower than)
Application B?

Correct: 𝑘=1


6:
What value(s) of k would make Application A grow at the same rate as Application B?

Correct: 𝑘=log𝑛
    

7:
Which application should you choose if you know that there are going to be 𝑛3 requests to find 
x in L?

Correct: Application B 
