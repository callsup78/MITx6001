Exercise 1 

Part 1: Function Types

For each of the following functions, specify the type of its return. You can assume each function is called with an appropriate
argument, as specified by its docstring.

If the output can be either an int or a float, select num, which isn't a real Python type, but which we'll use to indicate that
either basic numeric type is legal.

In fact, in Python, booleans True and False can be operated on as if they were the integers 1 and 0; but it is ugly and confusing
to take advantage of this fact, and we will resolutely pretend that it isn't true.

What are those lines under the function definitions?

def a(x):
	'''
    x: int or float.
    '''
    return x + 1

Indicate the type of the output that the function a will yield.
Correct: num


def b(x):
   '''
   x: int or float.
   '''
   return x + 1.0

Indicate the type of the output that the function b will yield.
Correct: float


def c(x, y):
   '''
   x: int or float. 
   y: int or float.
   '''
   return x + y

Indicate the type of the output that the function c will yield.
Correct: num


def d(x, y):
   '''
   x: Can be int or float.
   y: Can be int or float.
   '''
   return x > y
 
Indicate the type of the output that the function d will yield.
Correct: boolean


def e(x, y, z):
   '''
   x: Can be int or float.
   y: Can be int or float.
   z: Can be int or float.
   '''
   return x >= y and x <= z
 
Indicate the type of the output that the function e will yield.
Correct: boolean


def f(x, y):
   '''
   x: int or float.
   y: int or float
   '''
   x + y - 2

Indicate the type of the output that the function e will yield.
Correct: NoneType


---------- 
Exercise: square 

def square(x):
    '''
    x: int or float.
    '''
    return(x**2)
    
    
----------
Exercise: eval quadratic 

def evalQuadratic(a, b, c, x):
    '''
    a, b, c: numerical values for the coefficients of a quadratic equation
    x: numerical value at which to evaluate the quadratic.
    '''
    return((a * (x**2) + b * x + c))
    
    
----------
Exercise 2 

 You have the following function definitions:

def a(x):
   '''
   x: int or float.
   '''
   return x + 1

def b(x):
   '''
   x: int or float.
   '''
   return x + 1.0
  
def c(x, y):
   '''
   x: int or float. 
   y: int or float.
   '''
   return x + y

def d(x, y):
   '''
   x: Can be of any type.
   y: Can be of any type.
   '''
   return x > y

def e(x, y, z):
   '''
   x: Can be of any type.
   y: Can be of any type.
   z: Can be of any type.
   '''
   return x >= y and x <= z

def f(x, y):
   '''
   x: int or float.
   y: int or float
   '''
   x + y - 2  
    

Below is a transcript of a session with the Python shell. Provide the type and value of the expressions being evaluated. 
If evaluating an expression would cause an error, select NoneType and write 'error' in the box. If the value of an expression 
is a function, select function as the type and write 'function' in the box.

a(6)					- int  7
a(-5.3)					- float -4.3
a(a(a(6)))				- int 9
c(a(1), b(1))			- float 4.0
d('apple', 11.1)		- NoneType error
e(a(3), b(4), c(3, 4))  - boolean False
f 						- function function

----------
Exercise 3 

Assume the following definitions have been made:

def a(x, y, z):
     if x:
         return y
     else:
         return z

def b(q, r):
    return a(q>r, q, r)

a(False, 2, 3)	- int 3
b(3, 2)			- int 3
a(3>2, a, b)	- function function
b(a, b)			- NoneType error


----------
Exercise 4 

Below is a transcript of a session with the Python shell. Provide the type and value of the expressions being evaluated. If 
evaluating an expression would cause an error, select NoneType and write 'error' in the box. If the result is a function, select 
function and write 'function' in the box.

To get the most out of this problem, try to figure out the answers by reading the code, not running it. Run the code in your 
interpreter only after you've checked your answers a few times. 

>>> a = 10
>>> def f(x):
      return x + a
>>> a = 3
>>> f(1)
 
Correct: int 4


>>> x = 12
>>> def g(x):
      x = x + 1
      def h(y):
          return x + y
      return h(6)
>>> g(x)

Correct: int 19

 
----------
Exercise 5 

Enter the value of the expressions below.

To get the most out of this problem, try to figure out the answers by reading the code, not running it. Run the code only after
you've used up a few of your checks.

def foo(x, y = 5):
	def bar(x):
    	return x + 1
    return bar(y * 2)
              
foo(3)
Correct: 11     


def foo(x, y = 5):
	def bar(x):
    	return x + 1
	return bar(y * 2)
              
foo(3, 0)
Correct: 1  


def foo (x):
	def bar (z, x = 0):
       return z + x
    return bar(3, x)

foo(2)
Correct: 5 


def foo (x):
	def bar (z, x = 0):
       return z + x
    return bar(3)

foo(5)
Correct: 3

   
----------
Exercise 6

As we'll see in subsequent lectures, everything in Python is an object. Objects are special because we can associate special functions, referred to as object methods, with the object. In this problem you'll be working with string objects, and their built-in methods.

A complete description of the methods available to string objects can be found in the Python library reference on string methods.

In this exercise, we want you to get some experience in using methods as functions. The convention for object methods is to use the "dot" notation, so that if s is a string, evaluating s.upper will return the actual function, and evaluating s.upper() will cause the function itself to be evaluated (in this case it returns a new string, since strings are immutable) with every character now in upper case. An example of this follows:

>>> s = 'abc'
>>> s.capitalize
<built-in method capitalize of str object at 0x104c35878>
>>> s.capitalize()
'Abc'

For each of the expressions in this problem, specify its type and value. If it generates an error, select type 'NoneType' and put the word 'error' in the box for the value. If it would be a function, select type 'function' and put the word 'function' in the box for the value.

Assume we've made the following assignments:

> str1 = 'exterminate!' 
> str2 = 'number one - the larch'

Assume that the expressions are evaluated in the order shown - that is, each problem part is evaluated directly after the previous problem part(s). 


str1.upper
Correct: function function


str1.upper()
Correct: string EXTERMINATE!


str1
Correct: string exterminate!


str1.isupper()
Correct: boolean False


str1.islower()
Correct: boolean True


str2 = str2.capitalize()
str2
Correct: string Number one - the larch


str2.swapcase()
Correct: string nUMBER ONE - THE LARCH


str1.index('e')
Correct: int 0


str2.index('n')
Correct: int 8


str2.find('n')
Correct: int 8


str2.index('!')
Correct: NoneType error


str2.find('!')
Correct: -1


Note: Be sure to make note of the difference between the find and index string methods...

str1.count('e')
Correct: int 3



str1 = str1.replace('e', '*')
str1
Correct: sting *xt*rminat*!


str2.replace('one', 'seven') 
Correct: string Number seven - the larch


----------
Exercise: fourth power 

def fourthPower(x):
    '''
    x: int or float.
    '''
    return(square(square(x)))
    
    
----------
Exercise: odd 

def odd(x):
    '''
    x: int

    returns: True if x is odd, False otherwise
    '''
    return bool(x%2)
    
    
----------
Exercise: power iter 

def iterPower(base, exp):
    '''
    base: int or float.
    exp: int >= 0
 
    returns: int or float, base^exp
    '''
    result = 1
    while exp > 0:
        result *= base
        exp -= 1
    return result
    
    
----------
Exercise: power recur 

def recurPower(base, exp):
    '''
    base: int or float.
    exp: int >= 0
 
    returns: int or float, base^exp
    '''
    if exp == 0:
        return 1
    else:
        return base * recurPower(base, exp -1)
        
        
----------
Exercise: gcd iter 

def gcdIter(a, b):
    '''
    a, b: positive integers
    
    returns: a positive integer, the greatest common divisor of a & b.
    '''
    if a == b:
        return a
    place_holder = 0
    for gcd in range(1, max(a, b)):
        if (a % gcd == 0) & (b % gcd == 0):
            place_holder = gcd
    return place_holder
    

----------
Exercise: gcd recur

def gcdRecur(a, b):
    '''
    a, b: positive integers
    
    returns: a positive integer, the greatest common divisor of a & b.
    '''
    if b == 0:
        return a
    t = b
    b = a % b
    a = t
    return gcdRecur(a,b)    
----------
Exercise: is in

def isIn(char, aStr):
    '''
    char: a single character
    aStr: an alphabetized string
    
    returns: True if char is in aStr; False otherwise
    '''
    if len(aStr) == 0:
        return False
    elif len(aStr) == 1:
        return char == aStr
    else:
        mid = len(aStr)//2
    if char == aStr[mid]:
        return True
    elif char < aStr[mid]:
        return isIn(char, aStr[:mid])
    else:
        return isIn(char, aStr[mid+1:])
        
        
----------
Exercise 7 

Assume the two files below are in the same folder. You run inventory.py. What happens?
TWO FILES
FILE: batteries.py

aa = "AA"
aaa = "AAA"
c = "C"
d = "D" 

FILE: inventory.py

aa = "aa"
tripleA = "aaa"
print(aa)

Correct: prints aa
prints AA
There is an error.



Assume the two files below are in the same folder. You run inventory.py. What happens?
TWO FILES
FILE: batteries.py

aa = "AA"
aaa = "AAA"
c = "C"
d = "D" 

FILE: inventory.py

aa = "aa"
tripleA = "aaa"
print(batteries.aa)

prints aa
prints AA
Correct: There is an error.



Assume the two files below are in the same folder. You run inventory.py. What happens?
TWO FILES
FILE: batteries.py

aa = "AA"
aaa = "AAA"
c = "C"
d = "D" 

FILE: inventory.py

import batteries
aa = "aa"
tripleA = "aaa"
print(batteries.aa)

prints aa
Correct: prints AA
There is an error.



Assume the two files below are in the same folder. You run inventory.py. What happens?
TWO FILES
FILE: batteries.py

aa = "AA"
aaa = "AAA"
c = "C"
d = "D" 

FILE: inventory.py

from batteries import *
aa = "aa"
print(aa, aaa, c, d)

prints AA AAA C D
prints aa aaa c d
Correct: prints aa AAA C D
There is an error. 